iptables框架存在一些局限性，无法轻松解决：

避免代码重复和不一致：许多iptables扩展都是特定于协议的，因此没有统一的方式来匹配数据包字段，而是为它支持的每种协议都有一个扩展。这使代码库中的代码非常相似，可以执行类似的任务：有效负载匹配。
通过增强的通用集和映射基础结构，可以更快地进行数据包分类。
通过新的inet系列，简化了双堆栈IPv4 / IPv6管理，使您可以注册可查看IPv4和IPv6流量的基链。
更好的动态规则集更新支持。
就像其他Linux网络和Netfilter子系统一样，为第三方应用程序提供Netlink API。
解决语法不一致的问题，并提供更好，更紧凑的语法。

使用service iptables start启动iptables服务，但是iptables没有一个守护进程，所以不能算是真正意义上的服务，而应该算是内核提供的功能

规则：检测数据包，匹配则处理，如放行、拒绝、丢弃。存储在内核空间的信息包过滤表，这些规则指定：源地址 目的地址 传输协议 服务类型

Linux虚拟内存的大小为2^32（在32位的x86机器上），内核将这4G字节的空间分为两部分。最高的1G字节（从虚地址0xC0000000到0xFFFFFFFF）供内核使用，称为“内核空间”。而较低的3G字节（从虚地址0x00000000到0xBFFFFFFF），供各个进程使用，称为“用户空间”。也就是说，在这4G的内存中，0-3G是给用户留下的用户空间，这段空间是各个进程独立，无法互相访问的，3-4G是进程的内核空间，每个进程可以通过系统调用进入内核，因此，Linux内核空间由系统内的所有进程共享。

内核态与用户态是操作系统的两种运行级别
内核态：cpu可以访问内存的所有数据，包括外围设备，例如硬盘，网卡，cpu也可以将自己从一个程序切换到另一个程序。
用户态：只能受限的访问内存，且不允许访问外围设备，占用cpu的能力被剥夺，cpu资源可以被其他程序获取。
由于需要限制不同的程序之间的访问能力, 防止他们获取别的程序的内存数据, 或者获取外围设备的数据, 并发送到网络, CPU划分出两个权限等级 -- 用户态和内核态。
当我们在系统中执行一个程序时，大部分时间是运行在用户态下的，在其需要操作系统帮助完成某些它没有权力和能力完成的工作时就会切换到内核态

CPU的三种运行级别了，工作在内核态下的进程拥有最高级别Ring0，工作在用户态下的进程拥有最低级别Ring3，在Ring3状态下是不能访问Ring0状态下的地址和数据的。也就是说，进程在用户态下是没法访问到内核空间中的数据的，那么我们就看出这样做的好处了，通过内核态和用户态就产生了一个保护机制，用户无法随意的进入所有进程共享的内核空间。

为了让用户安全的访问内核空间，操作系统提供了以下几种方式：

1.系统调用进入内核态：如调用write(),read(),send()等IO函数等操作，进程就会进入内核态使用内核代码去完成操作。

2.异常：当CPU在执行运行在用户态的程序时，发现了某些事件不可知的异常，这是会触发由当前运行进程切换到处理此异常的内核相关程序中，也就到了内核态，比如缺页异常。

3.外围设备的中断：当外围设备完成用户请求的操作之后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条将要执行的指令转而去执行中断信号的处理程序，如果先执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了有用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。

那么进程是如何完成用户态到内核态的切换的呢？具体的步骤大致如下：

（1）从当前进程的描述符中提取其内核栈的ss0及esp0信息。
（2）使用ss0和esp0指向的内核栈将当前进程的cs,eip，eflags，ss,esp信息保存起来，这个过程也完成了由用户栈找到内核栈的切换过程，同时保存了被暂停执行的程序的下一条指令。
（3）将先前由中断向量检索得到的中断处理程序的cs，eip信息装入相应的寄存器，开始执行中断处理程序，这时就转到了内核态的程序执行了。
